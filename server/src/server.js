const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 5001;

app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use('/uploads', express.static(path.join(__dirname, '../../public/uploads')));

const uploadDir = path.join(__dirname, '../../public/uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });

const dbPath = path.join(__dirname, '../fashion_match.db');
const db = new sqlite3.Database(dbPath);

db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS wardrobe_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    category TEXT,
    color TEXT,
    style TEXT,
    image_url TEXT,
    purchase_price REAL,
    purchase_date TEXT,
    last_worn DATE,
    wear_count INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS combinations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    items TEXT,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS suggestions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    combination_id INTEGER,
    missing_item TEXT,
    purchase_link TEXT,
    description TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (combination_id) REFERENCES combinations(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS user_preferences (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    style_preference TEXT,
    color_preference TEXT,
    occasion_preference TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS combination_usage (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    combination_name TEXT,
    items TEXT,
    worn_date DATE,
    occasion TEXT,
    weather TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
  )`);
});

app.post('/api/wardrobe/upload', upload.single('image'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const { name, category, color, style, purchase_price, purchase_date } = req.body;
    const imageUrl = `/uploads/${req.file.filename}`;

    if (!purchase_price || parseFloat(purchase_price) <= 0) {
      return res.status(400).json({ error: 'Satın alma fiyatı gereklidir ve 0\'dan büyük olmalıdır' });
    }

    db.run(
      `INSERT INTO wardrobe_items (name, category, color, style, image_url, purchase_price, purchase_date) 
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [name || 'Untitled Item', category || 'other', color || 'unknown', style || 'casual', imageUrl, purchase_price, purchase_date || null],
      function(err) {
        if (err) {
          console.error('Database error:', err);
          return res.status(500).json({ error: err.message });
        }

        const newItem = {
          id: this.lastID,
          name: name || 'Untitled Item',
          category: category || 'other',
          color: color || 'unknown',
          style: style || 'casual',
          image_url: imageUrl
        };

        db.all('SELECT * FROM wardrobe_items', [], (err, rows) => {
          if (err) {
            console.error('Error fetching wardrobe:', err);
            return res.status(500).json({ error: err.message });
          }

          if (rows.length >= 2) {
            try {
              const combinations = generateCombinations(rows);
              res.json({
                item: newItem,
                autoGeneratedCombinations: combinations.length,
                message: `${combinations.length} kombin oluşturuldu`,
                shouldRedirectToSuggestions: true
              });
            } catch (comboError) {
              console.error('Error generating combinations:', comboError);
              res.json({
                item: newItem,
                autoGeneratedCombinations: 0,
                message: 'Kıyafet eklendi, kombin oluşturulurken hata oluştu',
                shouldRedirectToSuggestions: false
              });
            }
          } else {
            res.json({
              item: newItem,
              autoGeneratedCombinations: 0,
              message: 'Daha fazla kıyafet ekleyerek kombin oluşturabilirsiniz',
              shouldRedirectToSuggestions: false
            });
          }
        });
      }
    );
  } catch (error) {
    console.error('Upload error:', error);
    res.status(500).json({ error: error.message || 'Upload failed' });
  }
});

app.get('/api/wardrobe', (req, res) => {
  db.all('SELECT * FROM wardrobe_items ORDER BY created_at DESC', [], (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(rows);
  });
});

app.delete('/api/wardrobe/:id', (req, res) => {
  const id = req.params.id;
  db.run('DELETE FROM wardrobe_items WHERE id = ?', [id], function(err) {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json({ message: 'Item deleted', changes: this.changes });
  });
});

app.post('/api/combinations', (req, res) => {
  const { name, items, description } = req.body;
  const itemsJson = JSON.stringify(items);

  db.run(
    `INSERT INTO combinations (name, items, description) VALUES (?, ?, ?)`,
    [name || 'New Combination', itemsJson, description || ''],
    function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      res.json({
        id: this.lastID,
        name: name || 'New Combination',
        items: items,
        description: description || ''
      });
    }
  );
});

app.get('/api/combinations', (req, res) => {
  db.all('SELECT * FROM combinations ORDER BY created_at DESC', [], (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    const combinations = rows.map(row => ({
      ...row,
      items: JSON.parse(row.items)
    }));
    res.json(combinations);
  });
});

function getPurchaseLink(category, style, color) {
  const baseUrls = {
    'shoes': 'https://www.trendyol.com/ayakkabi',
    'outerwear': 'https://www.trendyol.com/dis-giyim',
    'accessories': 'https://www.trendyol.com/aksesuar',
    'bag': 'https://www.trendyol.com/canta',
    'belt': 'https://www.trendyol.com/kemer',
    'hat': 'https://www.trendyol.com/sapka',
    'scarf': 'https://www.trendyol.com/atki-esarp'
  };

  const categoryMap = {
    'shoes': 'shoes',
    'outerwear': 'outerwear',
    'jacket': 'outerwear',
    'coat': 'outerwear',
    'blazer': 'outerwear',
    'cardigan': 'outerwear',
    'accessories': 'accessories',
    'accessory': 'accessories',
    'bag': 'bag',
    'belt': 'belt',
    'hat': 'hat',
    'scarf': 'scarf'
  };

  const mappedCategory = categoryMap[category?.toLowerCase()] || 'accessories';
  return baseUrls[mappedCategory] || 'https://www.trendyol.com';
}

function generateCombinations(wardrobeItems) {
  const combinations = [];
  const categories = {
    'top': wardrobeItems.filter(item => ['top', 'shirt', 't-shirt', 'blouse', 'sweater', 'tshirt'].includes(item.category?.toLowerCase())),
    'bottom': wardrobeItems.filter(item => ['bottom', 'pants', 'jeans', 'skirt', 'shorts', 'pantolon', 'trouser'].includes(item.category?.toLowerCase())),
    'shoes': wardrobeItems.filter(item => ['shoes', 'sneakers', 'boots', 'heels', 'shoe', 'ayakkabi'].includes(item.category?.toLowerCase())),
    'outerwear': wardrobeItems.filter(item => ['jacket', 'coat', 'blazer', 'cardigan', 'outerwear', 'hırka', 'ceket'].includes(item.category?.toLowerCase())),
    'accessories': wardrobeItems.filter(item => ['accessory', 'accessories', 'bag', 'belt', 'hat', 'scarf', 'aksesuar', 'canta', 'kemer'].includes(item.category?.toLowerCase()))
  };

  const maxCombinations = 20;

  if (categories.top.length === 0 && categories.bottom.length === 0) {
    return combinations;
  }

  if (categories.top.length > 0 && categories.bottom.length > 0) {
    for (let i = 0; i < categories.top.length && combinations.length < maxCombinations; i++) {
      for (let j = 0; j < categories.bottom.length && combinations.length < maxCombinations; j++) {
        const combination = {
          items: [categories.top[i], categories.bottom[j]].filter(Boolean),
          name: `${categories.top[i]?.name || 'Üst'} + ${categories.bottom[j]?.name || 'Alt'}`,
          missingItems: [],
          suggestions: []
        };

      if (categories.shoes.length > 0) {
        const randomShoes = categories.shoes[Math.floor(Math.random() * categories.shoes.length)];
        combination.items.push(randomShoes);
      } else {
        const topStyle = categories.top[i]?.style || 'casual';
        const topColor = categories.top[i]?.color || 'unknown';
        combination.missingItems.push({
          category: 'shoes',
          itemName: 'Ayakkabı',
          description: `${topStyle} tarzda bir ayakkabı bu kombini tamamlar`,
          purchaseLink: getPurchaseLink('shoes', topStyle, topColor)
        });
      }

      if (categories.outerwear.length > 0 && Math.random() > 0.6) {
        const randomOuterwear = categories.outerwear[Math.floor(Math.random() * categories.outerwear.length)];
        combination.items.push(randomOuterwear);
      } else if (Math.random() > 0.5) {
        const topStyle = categories.top[i]?.style || 'casual';
        combination.missingItems.push({
          category: 'outerwear',
          itemName: 'Dış Giyim',
          description: `${topStyle} tarzda bir ceket veya hırka ekleyebilirsiniz`,
          purchaseLink: getPurchaseLink('outerwear', topStyle, 'unknown')
        });
      }

      if (categories.accessories.length > 0 && Math.random() > 0.7) {
        const randomAccessory = categories.accessories[Math.floor(Math.random() * categories.accessories.length)];
        combination.items.push(randomAccessory);
      } else if (Math.random() > 0.6) {
        const topStyle = categories.top[i]?.style || 'casual';
        combination.missingItems.push({
          category: 'accessories',
          itemName: 'Aksesuar',
          description: 'Çanta, kemer veya takı gibi aksesuarlar kombinasyonu zenginleştirir',
          purchaseLink: getPurchaseLink('accessories', topStyle, 'unknown')
        });
      }

      combinations.push(combination);
    }
    }
  } else if (categories.top.length >= 2) {
    for (let i = 0; i < categories.top.length && combinations.length < maxCombinations; i++) {
      for (let j = i + 1; j < categories.top.length && combinations.length < maxCombinations; j++) {
        const item1 = categories.top[i];
        const item2 = categories.top[j];
        
        const item1Name = (item1?.name || '').toLowerCase();
        const item2Name = (item2?.name || '').toLowerCase();
        const hasBottomItem = item1Name.includes('pantolon') || item1Name.includes('pants') || 
                             item1Name.includes('etek') || item1Name.includes('skirt') ||
                             item1Name.includes('short') || item1Name.includes('şort') ||
                             item2Name.includes('pantolon') || item2Name.includes('pants') ||
                             item2Name.includes('etek') || item2Name.includes('skirt') ||
                             item2Name.includes('short') || item2Name.includes('şort');
        
        const combination = {
          items: [item1, item2].filter(Boolean),
          name: `${item1?.name || 'Üst'} + ${item2?.name || 'Üst'}`,
          missingItems: [],
          suggestions: []
        };

        if (!hasBottomItem) {
          combination.missingItems.push({
            category: 'bottom',
            itemName: 'Alt Giyim',
            description: 'Bir pantolon veya etek bu kombini tamamlar',
            purchaseLink: 'https://www.trendyol.com/alt-giyim'
          });
        }

        if (categories.shoes.length > 0) {
          combination.items.push(categories.shoes[Math.floor(Math.random() * categories.shoes.length)]);
        } else {
          combination.missingItems.push({
            category: 'shoes',
            itemName: 'Ayakkabı',
            description: 'Ayakkabı bu kombini tamamlar',
            purchaseLink: getPurchaseLink('shoes', 'casual', 'unknown')
          });
        }

        combinations.push(combination);
      }
    }
  } else if (categories.bottom.length >= 2) {
    for (let i = 0; i < categories.bottom.length && combinations.length < maxCombinations; i++) {
      for (let j = i + 1; j < categories.bottom.length && combinations.length < maxCombinations; j++) {
        const combination = {
          items: [categories.bottom[i], categories.bottom[j]].filter(Boolean),
          name: `${categories.bottom[i]?.name || 'Alt'} + ${categories.bottom[j]?.name || 'Alt'}`,
          missingItems: [],
          suggestions: []
        };

        combination.missingItems.push({
          category: 'top',
          itemName: 'Üst Giyim',
          description: 'Bir üst giyim parçası bu kombini tamamlar',
          purchaseLink: 'https://www.trendyol.com/ust-giyim'
        });

        if (categories.shoes.length > 0) {
          combination.items.push(categories.shoes[Math.floor(Math.random() * categories.shoes.length)]);
        } else {
          combination.missingItems.push({
            category: 'shoes',
            itemName: 'Ayakkabı',
            description: 'Ayakkabı bu kombini tamamlar',
            purchaseLink: getPurchaseLink('shoes', 'casual', 'unknown')
          });
        }

        combinations.push(combination);
      }
    }
  }

  return combinations;
}

app.post('/api/suggestions/generate', (req, res) => {
  db.all('SELECT * FROM wardrobe_items', [], (err, rows) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }

    if (rows.length < 2) {
      return res.json({
        combinations: [],
        message: 'Add at least 2 items to your wardrobe to generate combinations'
      });
    }

    const combinations = generateCombinations(rows);
    res.json({ combinations });
  });
});

app.post('/api/suggestions/missing', (req, res) => {
  const { combinationId, missingItem, purchaseLink, description } = req.body;

  db.run(
    `INSERT INTO suggestions (combination_id, missing_item, purchase_link, description) 
     VALUES (?, ?, ?, ?)`,
    [combinationId, missingItem, purchaseLink, description],
    function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      res.json({
        id: this.lastID,
        combination_id: combinationId,
        missing_item: missingItem,
        purchase_link: purchaseLink,
        description: description
      });
    }
  );
});

app.post('/api/preferences', (req, res) => {
  const { stylePreference, colorPreference, occasionPreference } = req.body;

  db.run(
    `INSERT INTO user_preferences (style_preference, color_preference, occasion_preference) 
     VALUES (?, ?, ?)`,
    [stylePreference || 'casual', colorPreference || 'all', occasionPreference || 'daily'],
    function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }
      res.json({
        id: this.lastID,
        style_preference: stylePreference || 'casual',
        color_preference: colorPreference || 'all',
        occasion_preference: occasionPreference || 'daily'
      });
    }
  );
});

app.get('/api/preferences', (req, res) => {
  db.get('SELECT * FROM user_preferences ORDER BY created_at DESC LIMIT 1', [], (err, row) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }
    res.json(row || {});
  });
});

app.get('/api/statistics', (req, res) => {
  db.all('SELECT * FROM wardrobe_items', [], (err, items) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }

    const totalItems = items.length;
    let totalValue = 0;
    const colorCount = {};
    const styleCount = {};
    const categoryCount = {};
    const unusedItems = [];
    const currentDate = new Date();
    const thirtyDaysAgo = new Date(currentDate.getTime() - 30 * 24 * 60 * 60 * 1000);

    items.forEach(item => {
      if (item.purchase_price) {
        totalValue += parseFloat(item.purchase_price);
      }

      if (item.color && item.color !== 'unknown') {
        colorCount[item.color] = (colorCount[item.color] || 0) + 1;
      }

      if (item.style) {
        styleCount[item.style] = (styleCount[item.style] || 0) + 1;
      }

      if (item.category) {
        categoryCount[item.category] = (categoryCount[item.category] || 0) + 1;
      }

      if (!item.last_worn || (item.wear_count === 0 || item.wear_count === null)) {
        unusedItems.push(item);
      } else if (item.last_worn) {
        const lastWornDate = new Date(item.last_worn);
        if (lastWornDate < thirtyDaysAgo && item.wear_count < 2) {
          unusedItems.push(item);
        }
      }
    });

    const topColors = Object.entries(colorCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([color, count]) => ({ color, count }));

    const topStyles = Object.entries(styleCount)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([style, count]) => ({ style, count }));

    const season = getCurrentSeason();
    const seasonalItems = items.filter(item => {
      const itemSeason = getItemSeason(item.category, item.style);
      return itemSeason === season;
    });

    res.json({
      totalItems,
      totalValue: Math.round(totalValue * 100) / 100,
      topColors,
      topStyles,
      categoryCount,
      unusedItems: unusedItems.slice(0, 10),
      unusedCount: unusedItems.length,
      seasonalItems: seasonalItems.length,
      seasonalPercentage: totalItems > 0 ? Math.round((seasonalItems.length / totalItems) * 100) : 0
    });
  });
});

function getCurrentSeason() {
  const month = new Date().getMonth() + 1;
  if (month >= 3 && month <= 5) return 'spring';
  if (month >= 6 && month <= 8) return 'summer';
  if (month >= 9 && month <= 11) return 'autumn';
  return 'winter';
}

function getItemSeason(category, style) {
  if (category === 'outerwear' || category === 'jacket' || category === 'coat') {
    return 'winter';
  }
  if (style === 'sporty' || category === 'shoes') {
    return 'summer';
  }
  return 'all';
}


app.get('/api/weather', async (req, res) => {
  try {
    const https = require('https');
    const http = require('http');
    
    const options = {
      hostname: 'wttr.in',
      path: '/Istanbul?format=j1',
      method: 'GET',
      timeout: 5000
    };

    const request = https.request(options, (response) => {
      let data = '';

      response.on('data', (chunk) => {
        data += chunk;
      });

      response.on('end', () => {
        try {
          const weatherData = JSON.parse(data);
          const current = weatherData.current_condition[0];
          const temp = parseInt(current.temp_C);
          const code = parseInt(current.weatherCode);

          let condition = 'sunny';
          if (code >= 200 && code < 300) condition = 'rainy';
          else if (code >= 300 && code < 600) condition = 'rainy';
          else if (code >= 600 && code < 700) condition = 'cold';
          else if (code >= 700 && code < 800) condition = 'cloudy';
          else if (code >= 800) condition = code === 800 ? 'sunny' : 'cloudy';

          let recommendation = 'normal';
          if (temp < 10) recommendation = 'cold';
          else if (temp > 25) recommendation = 'hot';

          res.json({
            temperature: temp,
            condition: condition,
            recommendation: recommendation,
            city: 'Istanbul'
          });
        } catch (parseError) {
          console.error('Error parsing weather data:', parseError);
          return getFallbackWeather(res);
        }
      });
    });

    request.on('error', (error) => {
      console.error('Weather API error:', error);
      return getFallbackWeather(res);
    });

    request.on('timeout', () => {
      request.destroy();
      return getFallbackWeather(res);
    });

    request.end();
  } catch (error) {
    console.error('Weather request error:', error);
    return getFallbackWeather(res);
  }
});

function getFallbackWeather(res) {
  const month = new Date().getMonth() + 1;
  let temperature = 20;
  let condition = 'sunny';
  
  if (month >= 12 || month <= 2) {
    temperature = Math.floor(Math.random() * 8) + 3;
    const conditions = ['sunny', 'cloudy', 'cold'];
    condition = conditions[Math.floor(Math.random() * conditions.length)];
  } else if (month >= 6 && month <= 8) {
    temperature = Math.floor(Math.random() * 12) + 25;
    const conditions = ['sunny', 'cloudy'];
    condition = conditions[Math.floor(Math.random() * conditions.length)];
  } else {
    temperature = Math.floor(Math.random() * 12) + 15;
    const conditions = ['sunny', 'cloudy', 'rainy'];
    condition = conditions[Math.floor(Math.random() * conditions.length)];
  }
  
  let recommendation = 'normal';
  if (temperature < 10) {
    recommendation = 'cold';
  } else if (temperature > 25) {
    recommendation = 'hot';
  }
  
  res.json({
    temperature: temperature,
    condition: condition,
    recommendation: recommendation
  });
}

app.post('/api/suggestions/smart', (req, res) => {
  const { occasion, weather } = req.body;

  db.all('SELECT * FROM wardrobe_items', [], (err, items) => {
    if (err) {
      return res.status(500).json({ error: err.message });
    }

    if (items.length < 2) {
      return res.json({ combinations: [], message: 'Add at least 2 items to generate combinations' });
    }

    let filteredItems = [...items];

    if (weather === 'cold') {
      filteredItems = filteredItems.filter(item => 
        item.category === 'outerwear' || 
        item.style === 'formal' || 
        ['jacket', 'coat', 'sweater'].includes(item.category?.toLowerCase())
      );
    } else if (weather === 'hot') {
      filteredItems = filteredItems.filter(item => 
        !['outerwear', 'jacket', 'coat'].includes(item.category?.toLowerCase())
      );
    }

    const occasionStyles = {
      'work': ['formal', 'elegant'],
      'school': ['casual', 'minimalist'],
      'sport': ['sporty'],
      'evening': ['elegant', 'formal'],
      'daily': ['casual', 'minimalist']
    };

    const preferredStyles = occasionStyles[occasion] || ['casual'];

    if (occasion && occasion !== 'daily') {
      filteredItems = filteredItems.filter(item => 
        preferredStyles.includes(item.style)
      );
    }

    const combinations = generateSmartCombinations(filteredItems, occasion, weather);
    
    db.all('SELECT * FROM combination_usage', [], (err, usageRecords) => {
      if (err) {
        return res.json({ combinations, unwornCombinations: [] });
      }

      const wornCombinations = new Set(
        usageRecords.map(record => record.combination_name)
      );

      const unwornCombinations = combinations.filter(combo => 
        !wornCombinations.has(combo.name)
      ).slice(0, 5);

      res.json({ 
        combinations,
        unwornCombinations,
        colorHarmony: analyzeColorHarmony(combinations)
      });
    });
  });
});

function generateSmartCombinations(items, occasion, weather) {
  const combinations = generateCombinations(items);
  
  return combinations.map(combo => {
    const harmonyScore = calculateColorHarmony(combo.items);
    return {
      ...combo,
      harmonyScore,
      occasion,
      weatherRecommendation: weather || 'normal'
    };
  }).sort((a, b) => b.harmonyScore - a.harmonyScore).slice(0, 20);
}

function calculateColorHarmony(items) {
  const colors = items.map(item => item.color).filter(Boolean);
  if (colors.length < 2) return 5;

  const colorHarmonyMap = {
    'black': ['white', 'gray', 'red', 'blue'],
    'white': ['black', 'blue', 'pink', 'red'],
    'blue': ['white', 'gray', 'black', 'navy'],
    'red': ['black', 'white', 'blue', 'gray'],
    'gray': ['black', 'white', 'blue', 'pink'],
    'beyaz': ['siyah', 'mavi', 'kırmızı'],
    'siyah': ['beyaz', 'gri', 'kırmızı', 'mavi'],
    'mavi': ['beyaz', 'gri', 'siyah']
  };

  let score = 5;
  for (let i = 0; i < colors.length - 1; i++) {
    const currentColor = colors[i].toLowerCase();
    const nextColor = colors[i + 1].toLowerCase();
    
    if (colorHarmonyMap[currentColor]?.includes(nextColor)) {
      score += 2;
    } else if (currentColor === nextColor) {
      score += 1;
    } else {
      score -= 1;
    }
  }

  return Math.max(0, Math.min(10, score));
}

function analyzeColorHarmony(combinations) {
  const harmonyAnalysis = {
    excellent: combinations.filter(c => c.harmonyScore >= 8).length,
    good: combinations.filter(c => c.harmonyScore >= 6 && c.harmonyScore < 8).length,
    average: combinations.filter(c => c.harmonyScore >= 4 && c.harmonyScore < 6).length,
    poor: combinations.filter(c => c.harmonyScore < 4).length
  };

  return harmonyAnalysis;
}

app.post('/api/combinations/mark-worn', (req, res) => {
  const { combinationName, items, occasion, weather } = req.body;
  const today = new Date().toISOString().split('T')[0];

  db.run(
    `INSERT INTO combination_usage (combination_name, items, worn_date, occasion, weather) 
     VALUES (?, ?, ?, ?, ?)`,
    [combinationName, JSON.stringify(items), today, occasion || 'daily', weather || 'normal'],
    function(err) {
      if (err) {
        return res.status(500).json({ error: err.message });
      }

      items.forEach(itemId => {
        db.run(
          `UPDATE wardrobe_items 
           SET last_worn = ?, wear_count = COALESCE(wear_count, 0) + 1 
           WHERE id = ?`,
          [today, itemId],
          () => {}
        );
      });

      res.json({ success: true, id: this.lastID });
    }
  );
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

